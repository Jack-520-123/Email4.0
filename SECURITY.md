# å®‰å…¨æŒ‡å—

æ¬¢å–œé‚®ä»¶è¥é”€ç³»ç»Ÿçš„å®‰å…¨æŒ‡å—ï¼ŒåŒ…å«å®‰å…¨è§„èŒƒã€æœ€ä½³å®è·µå’Œå®‰å…¨é…ç½®è¯´æ˜ã€‚

## ğŸ”’ å®‰å…¨æ¦‚è¿°

### å®‰å…¨åŸåˆ™
1. **æœ€å°æƒé™åŸåˆ™**ï¼šç”¨æˆ·å’ŒæœåŠ¡åªè·å¾—å®Œæˆä»»åŠ¡æ‰€éœ€çš„æœ€å°æƒé™
2. **æ·±åº¦é˜²å¾¡**ï¼šå¤šå±‚å®‰å…¨é˜²æŠ¤ï¼Œç¡®ä¿å•ç‚¹å¤±è´¥ä¸ä¼šå¯¼è‡´æ•´ä½“å®‰å…¨å¤±æ•ˆ
3. **æ•°æ®ä¿æŠ¤**ï¼šä¿æŠ¤ç”¨æˆ·æ•°æ®å’Œæ•æ„Ÿä¿¡æ¯çš„æœºå¯†æ€§ã€å®Œæ•´æ€§å’Œå¯ç”¨æ€§
4. **é€æ˜åº¦**ï¼šå®‰å…¨æªæ–½å’Œæ”¿ç­–å¯¹ç”¨æˆ·é€æ˜
5. **æŒç»­æ”¹è¿›**ï¼šå®šæœŸè¯„ä¼°å’Œæ›´æ–°å®‰å…¨æªæ–½

### å®‰å…¨æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯å®‰å…¨å±‚                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ HTTPS å¼ºåˆ¶åŠ å¯†                                            â”‚
â”‚ â€¢ CSP å†…å®¹å®‰å…¨ç­–ç•¥                                          â”‚
â”‚ â€¢ XSS é˜²æŠ¤                                                 â”‚
â”‚ â€¢ CSRF ä»¤ç‰ŒéªŒè¯                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        API å®‰å…¨å±‚                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ JWT èº«ä»½éªŒè¯                                              â”‚
â”‚ â€¢ è¯·æ±‚é¢‘ç‡é™åˆ¶                                              â”‚
â”‚ â€¢ è¾“å…¥éªŒè¯å’Œæ¸…ç†                                            â”‚
â”‚ â€¢ æƒé™æ§åˆ¶                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       åº”ç”¨å®‰å…¨å±‚                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ ä¸šåŠ¡é€»è¾‘éªŒè¯                                              â”‚
â”‚ â€¢ æ•°æ®è®¿é—®æ§åˆ¶                                              â”‚
â”‚ â€¢ å®¡è®¡æ—¥å¿—                                                 â”‚
â”‚ â€¢ é”™è¯¯å¤„ç†                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       æ•°æ®å®‰å…¨å±‚                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ æ•°æ®åº“åŠ å¯†                                                â”‚
â”‚ â€¢ æ•æ„Ÿæ•°æ®è„±æ•                                              â”‚
â”‚ â€¢ å¤‡ä»½åŠ å¯†                                                 â”‚
â”‚ â€¢ è®¿é—®æ—¥å¿—                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ›¡ï¸ èº«ä»½éªŒè¯ä¸æˆæƒ

### JWT èº«ä»½éªŒè¯

#### é…ç½®è¦æ±‚
```typescript
// JWT é…ç½®ç¤ºä¾‹
const jwtConfig = {
  secret: process.env.JWT_SECRET, // è‡³å°‘ 32 å­—ç¬¦çš„å¼ºå¯†é’¥
  expiresIn: '24h', // ä»¤ç‰Œè¿‡æœŸæ—¶é—´
  algorithm: 'HS256', // ç­¾åç®—æ³•
  issuer: 'email-marketing-system',
  audience: 'email-marketing-users'
};
```

#### å®‰å…¨å®è·µ
```typescript
// âœ… å®‰å…¨çš„ JWT å®ç°
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';

// ç”Ÿæˆä»¤ç‰Œ
const generateToken = (userId: string, email: string) => {
  return jwt.sign(
    { 
      userId, 
      email,
      iat: Math.floor(Date.now() / 1000),
      jti: crypto.randomUUID() // å”¯ä¸€æ ‡è¯†ç¬¦
    },
    process.env.JWT_SECRET!,
    { 
      expiresIn: '24h',
      algorithm: 'HS256',
      issuer: 'email-marketing-system'
    }
  );
};

// éªŒè¯ä»¤ç‰Œ
const verifyToken = (token: string) => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET!, {
      algorithms: ['HS256'],
      issuer: 'email-marketing-system'
    });
  } catch (error) {
    throw new AuthenticationError('Invalid token');
  }
};
```

### å¯†ç å®‰å…¨

#### å¯†ç ç­–ç•¥
- **æœ€å°é•¿åº¦**ï¼š8 ä¸ªå­—ç¬¦
- **å¤æ‚æ€§è¦æ±‚**ï¼šåŒ…å«å¤§å°å†™å­—æ¯ã€æ•°å­—å’Œç‰¹æ®Šå­—ç¬¦
- **å†å²é™åˆ¶**ï¼šä¸èƒ½é‡å¤ä½¿ç”¨æœ€è¿‘ 5 ä¸ªå¯†ç 
- **è¿‡æœŸç­–ç•¥**ï¼šå»ºè®®æ¯ 90 å¤©æ›´æ¢å¯†ç 

#### å¯†ç å¤„ç†
```typescript
// âœ… å®‰å…¨çš„å¯†ç å¤„ç†
import bcrypt from 'bcryptjs';

// å¯†ç åŠ å¯†
const hashPassword = async (password: string): Promise<string> => {
  const saltRounds = 12; // æ¨èçš„ç›è½®æ•°
  return await bcrypt.hash(password, saltRounds);
};

// å¯†ç éªŒè¯
const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  return await bcrypt.compare(password, hash);
};

// å¯†ç å¼ºåº¦éªŒè¯
const validatePasswordStrength = (password: string): boolean => {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /\d/.test(password);
  const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
  
  return password.length >= minLength && 
         hasUpperCase && 
         hasLowerCase && 
         hasNumbers && 
         hasSpecialChar;
};
```

### æƒé™æ§åˆ¶

#### RBAC æ¨¡å‹
```typescript
// è§’è‰²å®šä¹‰
enum Role {
  ADMIN = 'admin',
  USER = 'user',
  VIEWER = 'viewer'
}

// æƒé™å®šä¹‰
enum Permission {
  READ_CAMPAIGNS = 'read:campaigns',
  WRITE_CAMPAIGNS = 'write:campaigns',
  DELETE_CAMPAIGNS = 'delete:campaigns',
  READ_RECIPIENTS = 'read:recipients',
  WRITE_RECIPIENTS = 'write:recipients',
  ADMIN_USERS = 'admin:users'
}

// è§’è‰²æƒé™æ˜ å°„
const rolePermissions: Record<Role, Permission[]> = {
  [Role.ADMIN]: [
    Permission.READ_CAMPAIGNS,
    Permission.WRITE_CAMPAIGNS,
    Permission.DELETE_CAMPAIGNS,
    Permission.READ_RECIPIENTS,
    Permission.WRITE_RECIPIENTS,
    Permission.ADMIN_USERS
  ],
  [Role.USER]: [
    Permission.READ_CAMPAIGNS,
    Permission.WRITE_CAMPAIGNS,
    Permission.READ_RECIPIENTS,
    Permission.WRITE_RECIPIENTS
  ],
  [Role.VIEWER]: [
    Permission.READ_CAMPAIGNS,
    Permission.READ_RECIPIENTS
  ]
};
```

#### æƒé™æ£€æŸ¥ä¸­é—´ä»¶
```typescript
// æƒé™æ£€æŸ¥ä¸­é—´ä»¶
const requirePermission = (permission: Permission) => {
  return async (req: AuthenticatedRequest, res: NextApiResponse, next: NextFunction) => {
    const user = req.user;
    
    if (!user) {
      return res.status(401).json({ error: 'Unauthorized' });
    }
    
    const userPermissions = rolePermissions[user.role] || [];
    
    if (!userPermissions.includes(permission)) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    
    next();
  };
};
```

## ğŸ” æ•°æ®ä¿æŠ¤

### æ•°æ®åŠ å¯†

#### ä¼ è¾“åŠ å¯†
- **HTTPS å¼ºåˆ¶**ï¼šæ‰€æœ‰é€šä¿¡å¿…é¡»ä½¿ç”¨ HTTPS
- **TLS ç‰ˆæœ¬**ï¼šæœ€ä½ TLS 1.2ï¼Œæ¨è TLS 1.3
- **è¯ä¹¦ç®¡ç†**ï¼šä½¿ç”¨æœ‰æ•ˆçš„ SSL/TLS è¯ä¹¦

#### å­˜å‚¨åŠ å¯†
```typescript
// æ•æ„Ÿæ•°æ®åŠ å¯†
import crypto from 'crypto';

class DataEncryption {
  private readonly algorithm = 'aes-256-gcm';
  private readonly key: Buffer;
  
  constructor() {
    this.key = crypto.scryptSync(process.env.ENCRYPTION_KEY!, 'salt', 32);
  }
  
  encrypt(text: string): { encrypted: string; iv: string; tag: string } {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.key, { iv });
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const tag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      tag: tag.toString('hex')
    };
  }
  
  decrypt(encryptedData: { encrypted: string; iv: string; tag: string }): string {
    const decipher = crypto.createDecipher(
      this.algorithm, 
      this.key, 
      { iv: Buffer.from(encryptedData.iv, 'hex') }
    );
    
    decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

### æ•°æ®è„±æ•

#### æ•æ„Ÿæ•°æ®å¤„ç†
```typescript
// æ•°æ®è„±æ•å·¥å…·
class DataMasking {
  // é‚®ç®±è„±æ•
  static maskEmail(email: string): string {
    const [username, domain] = email.split('@');
    const maskedUsername = username.length > 2 
      ? username.substring(0, 2) + '*'.repeat(username.length - 2)
      : '*'.repeat(username.length);
    return `${maskedUsername}@${domain}`;
  }
  
  // æ‰‹æœºå·è„±æ•
  static maskPhone(phone: string): string {
    return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  }
  
  // å§“åè„±æ•
  static maskName(name: string): string {
    if (name.length <= 1) return '*';
    if (name.length === 2) return name[0] + '*';
    return name[0] + '*'.repeat(name.length - 2) + name[name.length - 1];
  }
}
```

### æ•°æ®å¤‡ä»½å®‰å…¨

#### å¤‡ä»½ç­–ç•¥
```bash
#!/bin/bash
# å®‰å…¨å¤‡ä»½è„šæœ¬

# è®¾ç½®å˜é‡
BACKUP_DIR="/secure/backups"
DATE=$(date +%Y%m%d_%H%M%S)
ENCRYPTION_KEY="$BACKUP_ENCRYPTION_KEY"

# åˆ›å»ºæ•°æ®åº“å¤‡ä»½
pg_dump $DATABASE_URL > "$BACKUP_DIR/db_backup_$DATE.sql"

# åŠ å¯†å¤‡ä»½æ–‡ä»¶
gpg --symmetric --cipher-algo AES256 --compress-algo 1 \
    --s2k-mode 3 --s2k-digest-algo SHA512 --s2k-count 65536 \
    --passphrase "$ENCRYPTION_KEY" \
    "$BACKUP_DIR/db_backup_$DATE.sql"

# åˆ é™¤æœªåŠ å¯†çš„å¤‡ä»½
rm "$BACKUP_DIR/db_backup_$DATE.sql"

# æ¸…ç†æ—§å¤‡ä»½ï¼ˆä¿ç•™30å¤©ï¼‰
find "$BACKUP_DIR" -name "*.gpg" -mtime +30 -delete
```

## ğŸ›¡ï¸ è¾“å…¥éªŒè¯ä¸é˜²æŠ¤

### è¾“å…¥éªŒè¯

#### æ•°æ®éªŒè¯æ¨¡å¼
```typescript
// ä½¿ç”¨ Zod è¿›è¡Œè¾“å…¥éªŒè¯
import { z } from 'zod';

// é‚®ä»¶æ´»åŠ¨éªŒè¯æ¨¡å¼
const campaignSchema = z.object({
  name: z.string()
    .min(1, 'Campaign name is required')
    .max(100, 'Campaign name too long')
    .regex(/^[a-zA-Z0-9\s\-_]+$/, 'Invalid characters in campaign name'),
  
  subject: z.string()
    .min(1, 'Subject is required')
    .max(200, 'Subject too long'),
  
  content: z.string()
    .min(1, 'Content is required')
    .max(50000, 'Content too long'),
  
  recipients: z.array(z.string().email('Invalid email format'))
    .min(1, 'At least one recipient required')
    .max(10000, 'Too many recipients'),
  
  scheduledAt: z.date().optional(),
  
  settings: z.object({
    trackOpens: z.boolean().default(true),
    trackClicks: z.boolean().default(true),
    unsubscribeLink: z.boolean().default(true)
  }).optional()
});

// éªŒè¯ä¸­é—´ä»¶
const validateInput = (schema: z.ZodSchema) => {
  return (req: NextApiRequest, res: NextApiResponse, next: NextFunction) => {
    try {
      req.body = schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          error: 'Validation failed',
          details: error.errors
        });
      }
      next(error);
    }
  };
};
```

### XSS é˜²æŠ¤

#### å†…å®¹æ¸…ç†
```typescript
// XSS é˜²æŠ¤å·¥å…·
import DOMPurify from 'isomorphic-dompurify';

class XSSProtection {
  // æ¸…ç† HTML å†…å®¹
  static sanitizeHTML(html: string): string {
    return DOMPurify.sanitize(html, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'a', 'ul', 'ol', 'li'],
      ALLOWED_ATTR: ['href', 'target'],
      ALLOW_DATA_ATTR: false
    });
  }
  
  // è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
  static escapeHTML(text: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    };
    
    return text.replace(/[&<>"'/]/g, (s) => map[s]);
  }
}
```

#### CSP é…ç½®
```typescript
// Content Security Policy é…ç½®
const cspConfig = {
  'default-src': ["'self'"],
  'script-src': ["'self'", "'unsafe-inline'", 'https://trusted-cdn.com'],
  'style-src': ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
  'img-src': ["'self'", 'data:', 'https:'],
  'font-src': ["'self'", 'https://fonts.gstatic.com'],
  'connect-src': ["'self'", 'https://api.trusted-service.com'],
  'frame-ancestors': ["'none'"],
  'base-uri': ["'self'"],
  'form-action': ["'self'"]
};
```

### CSRF é˜²æŠ¤

#### CSRF ä»¤ç‰Œå®ç°
```typescript
// CSRF ä¿æŠ¤ä¸­é—´ä»¶
import csrf from 'csurf';

const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
});

// API è·¯ç”±ä¸­ä½¿ç”¨
export default function handler(req: NextApiRequest, res: NextApiResponse) {
  // åº”ç”¨ CSRF ä¿æŠ¤
  csrfProtection(req, res, () => {
    // å¤„ç†è¯·æ±‚é€»è¾‘
    handleRequest(req, res);
  });
}
```

## ğŸ” å®‰å…¨ç›‘æ§ä¸å®¡è®¡

### å®‰å…¨æ—¥å¿—

#### æ—¥å¿—è®°å½•ç­–ç•¥
```typescript
// å®‰å…¨äº‹ä»¶æ—¥å¿—
class SecurityLogger {
  private static instance: SecurityLogger;
  
  static getInstance(): SecurityLogger {
    if (!SecurityLogger.instance) {
      SecurityLogger.instance = new SecurityLogger();
    }
    return SecurityLogger.instance;
  }
  
  // ç™»å½•äº‹ä»¶
  logLoginAttempt(email: string, success: boolean, ip: string, userAgent: string) {
    const event = {
      type: 'LOGIN_ATTEMPT',
      email: this.maskEmail(email),
      success,
      ip: this.maskIP(ip),
      userAgent,
      timestamp: new Date().toISOString(),
      severity: success ? 'INFO' : 'WARNING'
    };
    
    this.writeLog(event);
  }
  
  // æƒé™è¿è§„
  logPermissionViolation(userId: string, action: string, resource: string, ip: string) {
    const event = {
      type: 'PERMISSION_VIOLATION',
      userId,
      action,
      resource,
      ip: this.maskIP(ip),
      timestamp: new Date().toISOString(),
      severity: 'ERROR'
    };
    
    this.writeLog(event);
  }
  
  // æ•°æ®è®¿é—®
  logDataAccess(userId: string, dataType: string, operation: string) {
    const event = {
      type: 'DATA_ACCESS',
      userId,
      dataType,
      operation,
      timestamp: new Date().toISOString(),
      severity: 'INFO'
    };
    
    this.writeLog(event);
  }
  
  private maskEmail(email: string): string {
    const [username, domain] = email.split('@');
    return `${username.substring(0, 2)}***@${domain}`;
  }
  
  private maskIP(ip: string): string {
    const parts = ip.split('.');
    return `${parts[0]}.${parts[1]}.***.**`;
  }
  
  private writeLog(event: any) {
    // å†™å…¥å®‰å…¨æ—¥å¿—æ–‡ä»¶æˆ–å‘é€åˆ°æ—¥å¿—æœåŠ¡
    console.log(JSON.stringify(event));
  }
}
```

### å¼‚å¸¸æ£€æµ‹

#### å¼‚å¸¸è¡Œä¸ºç›‘æ§
```typescript
// å¼‚å¸¸æ£€æµ‹æœåŠ¡
class AnomalyDetection {
  // æ£€æµ‹å¼‚å¸¸ç™»å½•
  static async detectAnomalousLogin(userId: string, ip: string): Promise<boolean> {
    // è·å–ç”¨æˆ·å†å²ç™»å½•è®°å½•
    const recentLogins = await this.getRecentLogins(userId, 30); // æœ€è¿‘30å¤©
    
    // æ£€æŸ¥IPåœ°å€å¼‚å¸¸
    const knownIPs = recentLogins.map(login => login.ip);
    const isNewIP = !knownIPs.includes(ip);
    
    // æ£€æŸ¥ç™»å½•é¢‘ç‡å¼‚å¸¸
    const todayLogins = recentLogins.filter(login => 
      this.isToday(login.timestamp)
    );
    const isHighFrequency = todayLogins.length > 10;
    
    return isNewIP || isHighFrequency;
  }
  
  // æ£€æµ‹å¼‚å¸¸é‚®ä»¶å‘é€
  static async detectAnomalousEmailSending(userId: string): Promise<boolean> {
    const recentSends = await this.getRecentEmailSends(userId, 24); // æœ€è¿‘24å°æ—¶
    
    // æ£€æŸ¥å‘é€é‡å¼‚å¸¸
    const totalEmails = recentSends.reduce((sum, send) => sum + send.count, 0);
    const isHighVolume = totalEmails > 1000; // 24å°æ—¶å†…è¶…è¿‡1000å°
    
    // æ£€æŸ¥å‘é€é¢‘ç‡å¼‚å¸¸
    const recentHour = recentSends.filter(send => 
      this.isWithinHour(send.timestamp)
    );
    const isHighFrequency = recentHour.length > 100; // 1å°æ—¶å†…è¶…è¿‡100æ¬¡å‘é€
    
    return isHighVolume || isHighFrequency;
  }
}
```

### å®‰å…¨å‘Šè­¦

#### å‘Šè­¦ç³»ç»Ÿ
```typescript
// å®‰å…¨å‘Šè­¦æœåŠ¡
class SecurityAlerts {
  // å‘é€å®‰å…¨å‘Šè­¦
  static async sendAlert(type: string, severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL', details: any) {
    const alert = {
      id: crypto.randomUUID(),
      type,
      severity,
      details,
      timestamp: new Date().toISOString(),
      status: 'OPEN'
    };
    
    // ä¿å­˜å‘Šè­¦è®°å½•
    await this.saveAlert(alert);
    
    // æ ¹æ®ä¸¥é‡ç¨‹åº¦å†³å®šé€šçŸ¥æ–¹å¼
    switch (severity) {
      case 'CRITICAL':
        await this.sendImmediateNotification(alert);
        break;
      case 'HIGH':
        await this.sendEmailNotification(alert);
        break;
      case 'MEDIUM':
        await this.addToDashboard(alert);
        break;
      case 'LOW':
        await this.logAlert(alert);
        break;
    }
  }
  
  // æ£€æŸ¥å¤šæ¬¡å¤±è´¥ç™»å½•
  static async checkFailedLogins(email: string, ip: string) {
    const failedAttempts = await this.getFailedLoginAttempts(email, ip, 15); // 15åˆ†é’Ÿå†…
    
    if (failedAttempts >= 5) {
      await this.sendAlert('BRUTE_FORCE_ATTACK', 'HIGH', {
        email,
        ip,
        attempts: failedAttempts,
        timeWindow: '15 minutes'
      });
      
      // ä¸´æ—¶é”å®šè´¦æˆ·
      await this.temporaryLockAccount(email, 30); // é”å®š30åˆ†é’Ÿ
    }
  }
}
```

## ğŸ”§ å®‰å…¨é…ç½®

### ç¯å¢ƒå˜é‡å®‰å…¨

#### æ•æ„Ÿä¿¡æ¯ç®¡ç†
```bash
# .env.example - ä¸åŒ…å«çœŸå®å€¼çš„æ¨¡æ¿
DATABASE_URL="postgresql://username:password@localhost:5432/dbname"
JWT_SECRET="your-super-secret-jwt-key-at-least-32-characters"
ENCRYPTION_KEY="your-encryption-key-for-sensitive-data"
SMTP_HOST="smtp.example.com"
SMTP_PORT="587"
SMTP_USER="your-smtp-username"
SMTP_PASS="your-smtp-password"
NEXTAUTH_SECRET="your-nextauth-secret"
NEXTAUTH_URL="http://localhost:3000"
```

#### ç”Ÿäº§ç¯å¢ƒé…ç½®
```typescript
// å®‰å…¨é…ç½®éªŒè¯
const validateSecurityConfig = () => {
  const requiredEnvVars = [
    'DATABASE_URL',
    'JWT_SECRET',
    'ENCRYPTION_KEY',
    'NEXTAUTH_SECRET'
  ];
  
  const missing = requiredEnvVars.filter(envVar => !process.env[envVar]);
  
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
  
  // éªŒè¯å¯†é’¥å¼ºåº¦
  if (process.env.JWT_SECRET!.length < 32) {
    throw new Error('JWT_SECRET must be at least 32 characters long');
  }
  
  // ç”Ÿäº§ç¯å¢ƒé¢å¤–æ£€æŸ¥
  if (process.env.NODE_ENV === 'production') {
    if (process.env.NEXTAUTH_URL?.startsWith('http://')) {
      throw new Error('NEXTAUTH_URL must use HTTPS in production');
    }
  }
};
```

### æ•°æ®åº“å®‰å…¨

#### è¿æ¥å®‰å…¨
```typescript
// å®‰å…¨çš„æ•°æ®åº“è¿æ¥é…ç½®
const databaseConfig = {
  url: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? {
    rejectUnauthorized: true,
    ca: process.env.DATABASE_CA_CERT
  } : false,
  connectionLimit: 10,
  acquireTimeout: 60000,
  timeout: 60000,
  log: ['error', 'warn'], // ä¸è®°å½•æŸ¥è¯¢æ—¥å¿—ä»¥é¿å…æ•æ„Ÿä¿¡æ¯æ³„éœ²
};
```

#### æŸ¥è¯¢å®‰å…¨
```typescript
// é˜²æ­¢ SQL æ³¨å…¥çš„æŸ¥è¯¢å®è·µ
class SecureDatabase {
  // âœ… ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
  static async getUserByEmail(email: string) {
    return await prisma.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        // ä¸é€‰æ‹©å¯†ç å­—æ®µ
      }
    });
  }
  
  // âœ… ä½¿ç”¨ Prisma çš„ç±»å‹å®‰å…¨æŸ¥è¯¢
  static async getCampaigns(userId: string, page: number = 1, limit: number = 20) {
    const offset = (page - 1) * limit;
    
    return await prisma.campaign.findMany({
      where: { userId }, // ç¡®ä¿ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„æ•°æ®
      select: {
        id: true,
        name: true,
        status: true,
        createdAt: true,
        _count: {
          select: { emails: true }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: offset,
      take: limit
    });
  }
}
```

## ğŸš¨ äº‹ä»¶å“åº”

### å®‰å…¨äº‹ä»¶åˆ†ç±»

#### äº‹ä»¶ä¸¥é‡ç¨‹åº¦
```typescript
enum SecurityEventSeverity {
  LOW = 'LOW',           // ä¿¡æ¯æ€§äº‹ä»¶ï¼Œæ— éœ€ç«‹å³è¡ŒåŠ¨
  MEDIUM = 'MEDIUM',     // éœ€è¦å…³æ³¨ï¼Œä½†ä¸ç´§æ€¥
  HIGH = 'HIGH',         // éœ€è¦å¿«é€Ÿå“åº”
  CRITICAL = 'CRITICAL'  // éœ€è¦ç«‹å³å“åº”
}

enum SecurityEventType {
  AUTHENTICATION_FAILURE = 'AUTH_FAILURE',
  AUTHORIZATION_VIOLATION = 'AUTHZ_VIOLATION',
  DATA_BREACH = 'DATA_BREACH',
  MALICIOUS_REQUEST = 'MALICIOUS_REQUEST',
  SYSTEM_COMPROMISE = 'SYSTEM_COMPROMISE',
  UNUSUAL_ACTIVITY = 'UNUSUAL_ACTIVITY'
}
```

### å“åº”æµç¨‹

#### è‡ªåŠ¨å“åº”æªæ–½
```typescript
// è‡ªåŠ¨å®‰å…¨å“åº”
class AutoSecurityResponse {
  // æ£€æµ‹åˆ°æš´åŠ›ç ´è§£æ”»å‡»æ—¶çš„å“åº”
  static async handleBruteForceAttack(ip: string, email: string) {
    // 1. ä¸´æ—¶å°ç¦ IP
    await this.blockIP(ip, 60); // å°ç¦60åˆ†é’Ÿ
    
    // 2. é”å®šç”¨æˆ·è´¦æˆ·
    await this.lockAccount(email, 30); // é”å®š30åˆ†é’Ÿ
    
    // 3. å‘é€å‘Šè­¦
    await SecurityAlerts.sendAlert('BRUTE_FORCE_ATTACK', 'HIGH', {
      ip,
      email,
      action: 'IP blocked and account locked'
    });
    
    // 4. è®°å½•äº‹ä»¶
    await this.logSecurityEvent({
      type: SecurityEventType.AUTHENTICATION_FAILURE,
      severity: SecurityEventSeverity.HIGH,
      details: { ip, email, response: 'auto_blocked' }
    });
  }
  
  // æ£€æµ‹åˆ°å¼‚å¸¸æ•°æ®è®¿é—®æ—¶çš„å“åº”
  static async handleAnomalousDataAccess(userId: string, dataType: string) {
    // 1. æš‚åœç”¨æˆ·ä¼šè¯
    await this.suspendUserSessions(userId);
    
    // 2. è¦æ±‚é‡æ–°è®¤è¯
    await this.requireReauthentication(userId);
    
    // 3. å‘é€å‘Šè­¦
    await SecurityAlerts.sendAlert('ANOMALOUS_DATA_ACCESS', 'MEDIUM', {
      userId,
      dataType,
      action: 'Session suspended, reauthentication required'
    });
  }
}
```

### æ¢å¤ç¨‹åº

#### å®‰å…¨äº‹ä»¶æ¢å¤
```typescript
// å®‰å…¨æ¢å¤ç¨‹åº
class SecurityRecovery {
  // æ•°æ®æ³„éœ²æ¢å¤ç¨‹åº
  static async handleDataBreach(affectedData: string[], severity: SecurityEventSeverity) {
    const recoveryPlan = {
      immediate: [
        'éš”ç¦»å—å½±å“çš„ç³»ç»Ÿ',
        'åœæ­¢æ•°æ®æ³„éœ²æº',
        'è¯„ä¼°æ³„éœ²èŒƒå›´',
        'é€šçŸ¥å®‰å…¨å›¢é˜Ÿ'
      ],
      shortTerm: [
        'ä¿®å¤å®‰å…¨æ¼æ´',
        'é‡ç½®å—å½±å“çš„å‡­æ®',
        'åŠ å¼ºç›‘æ§',
        'é€šçŸ¥å—å½±å“ç”¨æˆ·'
      ],
      longTerm: [
        'å®‰å…¨å®¡è®¡',
        'æ”¹è¿›å®‰å…¨æªæ–½',
        'å‘˜å·¥å®‰å…¨åŸ¹è®­',
        'æ›´æ–°å®‰å…¨æ”¿ç­–'
      ]
    };
    
    // æ‰§è¡Œç«‹å³å“åº”
    for (const action of recoveryPlan.immediate) {
      await this.executeRecoveryAction(action, affectedData);
    }
    
    // å®‰æ’çŸ­æœŸå’Œé•¿æœŸæ¢å¤ä»»åŠ¡
    await this.scheduleRecoveryTasks(recoveryPlan.shortTerm, 'short_term');
    await this.scheduleRecoveryTasks(recoveryPlan.longTerm, 'long_term');
  }
}
```

## ğŸ“‹ å®‰å…¨æ£€æŸ¥æ¸…å•

### éƒ¨ç½²å‰å®‰å…¨æ£€æŸ¥

```markdown
## ğŸ” éƒ¨ç½²å‰å®‰å…¨æ£€æŸ¥æ¸…å•

### èº«ä»½éªŒè¯ä¸æˆæƒ
- [ ] JWT å¯†é’¥å¼ºåº¦è¶³å¤Ÿï¼ˆè‡³å°‘32å­—ç¬¦ï¼‰
- [ ] å¯†ç ç­–ç•¥å·²é…ç½®
- [ ] æƒé™æ§åˆ¶å·²å®ç°
- [ ] ä¼šè¯ç®¡ç†å®‰å…¨

### æ•°æ®ä¿æŠ¤
- [ ] æ•æ„Ÿæ•°æ®å·²åŠ å¯†
- [ ] æ•°æ®åº“è¿æ¥ä½¿ç”¨SSL
- [ ] å¤‡ä»½å·²åŠ å¯†
- [ ] æ•°æ®è„±æ•å·²å®ç°

### è¾“å…¥éªŒè¯
- [ ] æ‰€æœ‰è¾“å…¥å·²éªŒè¯
- [ ] XSS é˜²æŠ¤å·²å¯ç”¨
- [ ] CSRF ä¿æŠ¤å·²é…ç½®
- [ ] SQL æ³¨å…¥é˜²æŠ¤å·²å®ç°

### ç½‘ç»œå®‰å…¨
- [ ] HTTPS å·²å¼ºåˆ¶å¯ç”¨
- [ ] CSP ç­–ç•¥å·²é…ç½®
- [ ] å®‰å…¨å¤´å·²è®¾ç½®
- [ ] CORS ç­–ç•¥å·²é…ç½®

### ç›‘æ§ä¸æ—¥å¿—
- [ ] å®‰å…¨æ—¥å¿—å·²é…ç½®
- [ ] å¼‚å¸¸æ£€æµ‹å·²å¯ç”¨
- [ ] å‘Šè­¦ç³»ç»Ÿå·²è®¾ç½®
- [ ] å®¡è®¡è·Ÿè¸ªå·²å®ç°

### ç¯å¢ƒé…ç½®
- [ ] ç”Ÿäº§ç¯å¢ƒå˜é‡å·²è®¾ç½®
- [ ] è°ƒè¯•æ¨¡å¼å·²å…³é—­
- [ ] é”™è¯¯ä¿¡æ¯å·²è„±æ•
- [ ] é»˜è®¤å‡­æ®å·²æ›´æ”¹
```

### å®šæœŸå®‰å…¨å®¡æŸ¥

```markdown
## ğŸ“… å®šæœŸå®‰å…¨å®¡æŸ¥è®¡åˆ’

### æ¯å‘¨æ£€æŸ¥
- [ ] å®‰å…¨æ—¥å¿—å®¡æŸ¥
- [ ] å¼‚å¸¸æ´»åŠ¨æ£€æŸ¥
- [ ] ç³»ç»Ÿæ›´æ–°æ£€æŸ¥
- [ ] å¤‡ä»½éªŒè¯

### æ¯æœˆæ£€æŸ¥
- [ ] æƒé™å®¡æŸ¥
- [ ] å¯†ç ç­–ç•¥åˆè§„æ€§
- [ ] å®‰å…¨é…ç½®å®¡æŸ¥
- [ ] æ¼æ´æ‰«æ

### æ¯å­£åº¦æ£€æŸ¥
- [ ] å®‰å…¨æ”¿ç­–æ›´æ–°
- [ ] å‘˜å·¥å®‰å…¨åŸ¹è®­
- [ ] æ¸—é€æµ‹è¯•
- [ ] ä¸šåŠ¡è¿ç»­æ€§æµ‹è¯•

### å¹´åº¦æ£€æŸ¥
- [ ] å…¨é¢å®‰å…¨å®¡è®¡
- [ ] é£é™©è¯„ä¼°
- [ ] åˆè§„æ€§æ£€æŸ¥
- [ ] å®‰å…¨æ¶æ„å®¡æŸ¥
```

## ğŸ“ å®‰å…¨è”ç³»æ–¹å¼

### å®‰å…¨äº‹ä»¶æŠ¥å‘Š
- **ç´§æ€¥å®‰å…¨äº‹ä»¶**ï¼šsecurity-emergency@your-domain.com
- **ä¸€èˆ¬å®‰å…¨é—®é¢˜**ï¼šsecurity@your-domain.com
- **æ¼æ´æŠ¥å‘Š**ï¼švulnerability@your-domain.com

### å®‰å…¨å›¢é˜Ÿ
- **é¦–å¸­å®‰å…¨å®˜**ï¼šcso@your-domain.com
- **å®‰å…¨å·¥ç¨‹å¸ˆ**ï¼šsecurity-engineering@your-domain.com
- **åˆè§„å®˜**ï¼šcompliance@your-domain.com

---

**è®°ä½ï¼šå®‰å…¨æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦æ‰€æœ‰å›¢é˜Ÿæˆå‘˜çš„å…±åŒåŠªåŠ›ï¼** ğŸ”’